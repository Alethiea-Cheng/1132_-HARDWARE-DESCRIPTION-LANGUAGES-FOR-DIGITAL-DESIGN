#include <stdio.h>
#include <stdint.h>
#include <math.h>

#define ITERATIONS 100
#define Q9_55_SHIFT 55

// Q9.55格式的arctan(1/2^n) degree表
uint64_t arctan_table_q955[64] = {
    0x1680000000000000, 0x0d485398d30ee200, 0x0704a3a03eb80b80, 0x0390008924ffd060,
    0x01c9c55326164cf0, 0x00e51bca72971540, 0x0072950d58cc3ad8, 0x00394b6bd0893ee4,
    0x001ca5d28dcac943, 0x000e52ecdb9e3864, 0x00072976e066771f, 0x000394bb7e8628f1,
    0x0001ca5dc10d7235, 0x0000e52ee0c004d2, 0x0000729770672be0, 0x0000394bb8347b1f,
    0x00001ca5dc1a5a35, 0x00000e52ee0d30af, 0x00000729770698ca, 0x00000394bb834c73,
    0x000001ca5dc1a63c, 0x000000e52ee0d31e, 0x000000729770698f, 0x000000394bb834c8,
    0x0000001ca5dc1a64, 0x0000000e52ee0d32, 0x0000000729770699, 0x0000000394bb834c,
    0x00000001ca5dc1a6, 0x00000000e52ee0d3, 0x000000007297706a, 0x00000000394bb835,
    0x000000001ca5dc1a, 0x000000000e52ee0d, 0x0000000007297707, 0x000000000394bb83,
    0x0000000001ca5dc2, 0x0000000000e52ee1, 0x0000000000729770, 0x0000000000394bb8,
    0x00000000001ca5dc, 0x00000000000e52ee, 0x0000000000072977, 0x00000000000394bc,
    0x000000000001ca5e, 0x000000000000e52f, 0x0000000000007297, 0x000000000000394c,
    0x0000000000001ca6, 0x0000000000000e53, 0x0000000000000729, 0x0000000000000395,
    0x00000000000001ca, 0x00000000000000e5, 0x0000000000000073, 0x0000000000000039,
    0x000000000000001d, 0x000000000000000e, 0x0000000000000007, 0x0000000000000004,
    0x0000000000000002, 0x0000000000000001, 0x0000000000000000, 0x0000000000000000
};

int main() {
    int n;
    double X, Y, Z;
    double K;
    int d;

    // 初始值
    X = 1.0;
    Y = 0.0;
    Z = 27.0;  // 初始旋轉角度 45度

    printf("Iter | Xn+1               | Yn+1               | Zn+1\n");
    printf("----------------------------------------------------------------------------\n");

    for (n = 0; n < ITERATIONS; n++) {
        // 超過表格範圍時，直接補0
        double atan_deg;
        if (n < 64) {
            atan_deg = (double)((int64_t)arctan_table_q955[n]) / (1LL << Q9_55_SHIFT);
        } else {
            atan_deg = 0.0;
        }

        // 每次迭代要乘的縮放因子
        K = 1.0 / sqrt(1.0 + pow(2.0, -2 * n));

        // 判定旋轉方向
        d = (Z >= 0) ? 1 : -1;

        // 暫存本次迭代後的X、Y
        double Xn1 = K * (X - d * Y * pow(2.0, -n));
        double Yn1 = K * (Y + d * X * pow(2.0, -n));
        double Zn1 = Z - d * atan_deg;

        // 印出本次結果
        printf("%4d | %.15f | %.15f | %.15f\n", n, Xn1, Yn1, Zn1);

        // 更新
        X = Xn1;
        Y = Yn1;
        Z = Zn1;
    }

    return 0;
}
